#!/usr/bin/env python
"""
Watch the PPA building the python packages after upload
"""
import sys, os
import time

from twisted.python import usage

from launchpadlib.credentials import Credentials
from launchpadlib.launchpad import Launchpad, STAGING_SERVICE_ROOT, EDGE_SERVICE_ROOT

CLIENTNAME = 'Hypy LPTool'
PACKAGE = "python-hypy"
PPA = "ppa"
POCKET = "Release"


class CannotWait(Exception):
    """
    WaitBuilding failed because there was a timeout OR the packages did not
    enter a completed state OR the packages weren't even being built.
    """


class AuthorizedCommand(usage.Options):
    """
    A subcommand that relies on launchpad authorization
    """
    def postOptions(self):
        if self.parent['lpuser'] is None:
            raise usage.UsageError("** Must provide -u EMAIL parameter to log into launchpad.net")

        if self.parent['staging']:
            self['rooturi'] = STAGING_SERVICE_ROOT
            credFilename = self.parent['lpuser'] + '@staging'
        else:
            self['rooturi'] = EDGE_SERVICE_ROOT
            credFilename = self.parent['lpuser'] + '@edge'

        credentials = Credentials()
        credentials.load(open(os.path.expanduser("~/.launchpadlib/%s" %
            (credFilename,))))
        cachedir = os.path.expanduser("~/.launchpadlib/cache")
        self.launchpad = Launchpad(credentials, self['rooturi'], cachedir)


class WaitBuilding(AuthorizedCommand):
    """
    Wait for a source build to complete
    """
    synopsis = "VERSION"

    optParameters = [["timeout", "t", 15, "Time, in minutes, to wait for successful builds"],
    ]

    def parseArgs(self, version):
        self['version'] = version

    def postOptions(self):
        AuthorizedCommand.postOptions(self)
        self['timeout'] = int(self['timeout'])

        person = self.launchpad.people.getByEmail(email=self.parent['lpuser'])
        ppa = person.getPPAByName(name=PPA)

        # first wait for the package to be accepted, by waiting for the source
        # to appear
        for x in range(0, self['timeout']*3):
            sources = ppa.getPublishedSources(version=self['version'], 
                    source_name=PACKAGE)
            try:
                sources[0]
                print "Package was accepted."
                break
            except IndexError:
                print "Version %s packages not yet accepted by the PPA.  Waiting 20s..." % (self['version'],)
                time.sleep(20)

        else:
            raise CannotWait(
                    "Timed out waiting for packages at version %s to be accepted" %
                        (self['version'],)
                        )

        # get the special id off the url; not exposed directly to the API
        # anywhere
        sourceId = sources[0].self_link.rsplit('/', 1)[-1]

        # now wait for the packages to be built
        for x in range(0, self['timeout']):
            _summaries = ppa.getBuildSummariesForSourceIds(source_ids=sourceId)
            summary = _summaries[sourceId]

            built = 0
            needed = len(summary['builds'])

            for build in summary['builds']:
                if build['datebuilt'] is None:
                    print "BUILDING:", build['title']
                else:
                    built += 1

            if summary['status'] in ["NEEDSBUILD", "BUILDING"]:
                print "%s/%s packages finished.  Waiting 60s..." % (
                        built, needed)
            else:
                if summary['status'] == "FULLYBUILT":
                    print "%s/%s packages were built" % (built, needed)
                    break
                print summary['status']
                for build in summary['builds']:
                    print build['buildstate'], '-', build['title']
                raise CannotWait("couldn't get all %s packages published" % (
                        needed,))
            time.sleep(60)
        else:
            raise CannotWait("timed out after %s minutes" % (self['timeout'],))


class CopyBinaries(AuthorizedCommand):
    """
    Sync packages in the PPA between two dists
    """
    optParameters = [["to", "t", None, "Dist to copy packages to"],
            ]
    
    def parseArgs(self, version):
        self['version'] = version

    def postOptions(self):
        AuthorizedCommand.postOptions(self)
        person = self.launchpad.people.getByEmail(email=self.parent['lpuser'])
        ppa = person.getPPAByName(name=PPA)
        ppa.syncSource(from_archive=ppa, 
                include_binaries=True,
                source_name=PACKAGE, 
                to_series=self['to'],
                to_pocket=POCKET,
                version=self['version']
                )
        print "synced %s %s to %s" % (PACKAGE, self['version'], self['to'])


class NewAuth(usage.Options):
    """
    Create a new set of credentials, writing it to stdout
    """
    def postOptions(self):
        if self.parent['staging']:
            self['rooturi'] = STAGING_SERVICE_ROOT
        else:
            self['rooturi'] = EDGE_SERVICE_ROOT

        try:
            real_stdout = sys.stdout
            sys.stdout = sys.stderr
            cachedir = os.path.expanduser("~/.launchpadlib/cache")
            launchpad = Launchpad.get_token_and_login(CLIENTNAME,
                    self['rooturi'], cachedir)
        finally:
            sys.stdout = real_stdout

        launchpad.credentials.save(sys.stdout)


class Options(usage.Options):
    synopsis = "lptool"
    optParameters = [
        ['lpuser', 'u', None, "Email address of a user authorized on launchpad"],
    ]

    optFlags = [
        ['staging', 'S', 'Use the staging (demo) area'],
    ]

    subCommands = [
        ["wait-building", "w", WaitBuilding, 
            "Wait for an uploaded package to finish building"],
        ["copy-binaries", "c", CopyBinaries, 
            "Copy built packages from one dist to another"],
        ["new-auth", None, NewAuth, 
            "Create a new set of credentials, writing it to stdout"],
        ]

    def postOptions(self):
        """Recommended if there are subcommands:"""
        if self.subCommand is None:
            self.synopsis = "lptool <subcommand>"
            raise usage.UsageError("** Please specify a subcommand (see \"Commands\").")


def run(argv=None):
    if argv is None:
        argv = sys.argv
    o = Options()
    try:
        o.parseOptions(argv[1:])
    except usage.UsageError, e:
        if hasattr(o, 'subOptions'):
            print str(o.subOptions)
        else:
            print str(o)
        print str(e)
        return 1
    except CannotWait, e:
        print "** wait-building failed:", e.args[0]
        return 1

    return 0


if __name__ == '__main__': sys.exit(run())

